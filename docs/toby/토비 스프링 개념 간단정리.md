

# 토비의 스프링 3.0 개념 간단하게

> 스프링 프레임워크에 대해 공부하면서 좀 더 자세하게 원리를 공부하고 싶어져서 
>
> 이해한 내용을 정리하게 되었다. 
>
> 최종 업데이트 _ 2021 - 02 - 28



<h3>
    이번 챕터에서 정리하고자 하는 내용<hr>
</h3>
<ul style="list-style:none;">
    <li><a href="#sec_target1" style="text-decoration:none;">1. 관심사의 분리 62p </a></li>
    <li><a href="#sec_target2" style="text-decoration:none;">2. 제어의 역전 (IoC) 90p</a></li>
    <li><a href="#sec_target3" style="text-decoration:none;">3. 의존관계 주입 (DI) 113p </a></li>
    <li><a href="#sec_target5" style="text-decoration:none;">부록. <b>스프링 용어 정리</b></b></a></li></ul>




<div class="sec1">
    <a name="sec_target1"></a>
	<h3>1. 관심사의 분리 62p</h3>
    <hr>
</div>




### 관심사의 분리 ( Seperation of Concerns ) 란? 

- 관심이 같은 것 끼리는 하나의 객체 안으로 또는 관련된 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않도록 분리하는 것.



##### 그러한 이유는?

  소프트웨어의 개발에서는 끝이란 없다. 새로운 문제 상황이 발생하고 그에 대한 요구가 일어난다. 따라서 개발자들이 설계 할 때 가장 염두해야 하는 사항은 **바로 미래의 변화를 어떻게 대비할 것인가** 이다.  그리고 그 변화는 며칠 내에, 몇 시간 후에 발생할 수 있다.

  그러한 변화 혹은 문제에 대해 효율적으로 대처할 수 있어야 하기 때문에 **분리**와 **확장**을 고려한 설계를 공부해야한다. 

#####  얻는 것은?

  예를 들어, 단순히 DB 접속용 암호를 변경하려고 DAO 클래스 수백 개를 모두 수정해야한다면? 혹은 내 첫 웹개발 경험으로, 똑같은 네이버맵 API 스크립트를 적용하려고 모든 jsp 파일에 동일한 코드를 복사해 붙여 넣어 줘야한다면? 트랜잭션 기술을 다른 것으로 바꿨다고 비즈니스 로직이 담긴 코드의 구조를 모두 변경해야한다면? 

  변화가 한 번에 한 가지 **관심**에 집중되어 일어나면 우리가 할 일은 한 가지 관심이 한 군데에 집중되게 하면 된다.  그래서 객체지향 이론에서 관심사의 분리를 통해 같은 관심에 효과적으로 집중할 수 있게 만들어준다. 



관련하여 ppt를 만들어보았다.



<div class="sec2">
    <a name="sec_target2"></a>
	<h3>2. 제어의 역전 (IoC) 90p</h3>
    <hr>
</div>

##### 

#### 제어의 역전 ( Inverse of Control )

- 프로그램 제어 흐름 구조가 뒤바뀌는 것
- 객체가 자신이 사용할 객체를 스스로 선택하지 않을 뿐만 아니라 생성도 하지 않음. 모든 객체가 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어짐. ( EX. 스프링 컨테이너)



##### 예시) 서블릿 컨테이너, 

- 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출.. 등



제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다는, 제어의 역전 개념

템플릿 메소드는 제어의 역전 개념을 활용해 문제를 해결하는 디자인 패턴이라 볼 수 있음



#### 라이브러리 VS 프레임 워크

- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어하며 동작하는 중에 필요한 기능이 있을 땐 능동적으로 라이브러리 사용함

- 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임 워크에 의해 사용됨.

프레임워크 위에 개발한 클래스를 등록을 하면, 프레임워크가 흐름을 주도하는 중에 해당 애플리케이션 코드를 사용하도록 만드는 방식. 

따라서 제어의 역전 개념이 적용되어있음.







<div class="sec3">
    <a name="sec_target3"></a>
	<h3>3. 의존관계 주입 (DI) 113p</h3>
    <hr>
</div>



#####  도입 배경 

스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확히 설명하지 못함. 왜냐하면, 스프링이 서블릿 컨테이너 처럼 서버에서 동작하는 서비스 컨테이너라는 뜻인지, 아니면 단순히 IoC 개념이 적용된 템플릿 메소드 패턴을 이용해 만들어진 프레임워크인지, 아니면 또 다른 IoC 특징을 지닌 기술이라는 것인지 파악하기 힘듬. 

:star: 스프링이 제공하는 IoC 방식의 핵심을 짚어주는 `의존관계 주입(Dependency Injection)` 이라는 좀 더 의도가 명확히 드러나는 이름을 사용하게 됨.  다시 말해 스프링이 여타 프레임워크와 차별화하는 부분임. ` 의존관계 주입 컨테이너` 또는 `DI 컨테이너` 라고도 불린다.



##### 의존 관계란 ? 

![](https://github.com/junhochoi-git/springboot_tutorial_1/blob/master/docs/toby/illustration/dependency.JPG?raw=true)

- UML 모델 에서 두 클래스 A와 B가 `의존관계` `dependency relationship` 에 있음을 *해당 그림과 같이 점선으로 된 화살표로 표현함. (해당 모델을 자동으로 그려주는 툴도 있다는 걸 배웠었지.)

A가 B에 의존하고 있음을 나타냄.  *클래스의 의존관계 다이어그램.

방향성을 갖기 때문에, B는 A의 변화에 영향을 받지 않음



##### '의존한다' 는 무슨 의미?

의존 대상인 B 가 변하면 그것이 A에 영향을 미친다는 뜻!

다시 말해, B에 기능이 추가되거나 변경되거나, 형식이 바뀌거나 하면 그 영향이 A로 전달된다는 의미.



##### 만약 그렇게 되면? 

A도 그에 따라 수정되거나 추가되어야 할 것!



![dependency2.JPG](https://github.com/junhochoi-git/springboot_tutorial_1/blob/master/docs/toby/illustration/dependency2.JPG?raw=true)

인터페이스를 통한 느슨한 결합을 갖는 의존 관계!

- UserDAO 클래스는 ConnectionMaker 인터페이스에 대해서만 직접 의존함
- UserDAO 클래스는 D_ConnectionMaker 클래스의 존재도 알지 못함

**설계 모델 관점 UML 에서 말하는 의존 관계다!**



#### 런타임 시에 만들어지는 의존 관계에 대하여

앞서 말한 설계 시점의 의존관계와는 성격이 다름! ( 설계 시점의 의존관계의 실체화) 

프로그램이 시작되고 UserDao 객체가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, `의존 오브젝트` ( Dependent object) 라 말하고 **의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체( 보통 클라이언트라 불리는) 오브젝트를 런타임 시에 연결해주는 작업을 말하게 된다.**



#### 의존관계 주입 정리 

- 인터페이스에만 의존하여 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 
- 런타임 시점의 의존관계는 컨테이너나 팩토리같은 **제3의존재**가 결정한다. `애플리케이션 컨텍스트` , `빈 팩토리`, `IoC 컨테이너` 등 
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 **주입**(제공) 함으로써 만들어진다





<div class="sec5">
    <a name="sec_target5"></a>
	<h3>부록. 스프링 용어 정리</h3>
    <hr>
</div>

1. `빈`( Bean) : 스프링이 IoC 방식으로 관리하는 객체라는 뜻, 관리되는 객체( managed object) 라 부르기도 하며 스프링을 사용하는 애플리케이션에서 만들어지는 모든 객체가 전부 `빈` 은 아니라는 것을 주의하자.

   **스프링이 직접 그 생성과 제어를 담당하는 객체만을 `빈`이라**고 부른다!



2. `빈 팩토리` ( Bean Factory ) : 스프링의 IoC 담당 핵심 컨테이너를 가르킴. 빈을 등록하고, 생성하고, 조회하고, 돌려주고 그리고 그 외 부가적인 빈을 관리하는 기능을 담당한다. 보통 이를 확장한 `애플리케이션 컨텍스트` 를 사용한다.



3. `애플리케이션 컨텍스트` (Application Context) : 빈 팩토리를 확장한 IoC 컨테이너.  기본적인 기능은 빈 팩토리와 동일하지만 스프링이 제공하는 각종 부가 서비스를 추가 제공함. 빈의 생성과 제어의 관점과 스프링이 제공하는 애플리케이션 지원 기능에 대한 관점에 따라 2번 과 3번을 구분할 수 있다. 설명에서 알 수 있듯, ApplicationContext 는 Bean Factory 를 상속함.



4. `설정정보/ 설정 메타 정보` ( Configuration metadata ) : 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC 를 적용하기 위해 사용하는 메타정보. 이는 `형상정보`라 많이 불린다. IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 떄 사용. 



5. `컨테이너 또는 IoC컨테이너` : IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를  `컨테이너 `또는` IoC컨테이너`라 부른다. 긴 애플리케이션 컨텍스트 대신 `스프링 컨테이너` 라고도 부른다. ( 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용되기 때문에 통들어 `스프링 컨테이너` 라고 부르는 것.



6. `스프링 프레임워크` : IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용되고, `스프링` 이라고 줄여서 말하기도 함. 

 
